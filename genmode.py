from __future__ import print_function
import os
import datetime
import shutil
import time
import argparse
import numpy as np
import outcar
from constant import *

parser = argparse.ArgumentParser()
parser.add_argument('-i', '--input',
                    help = 'Input (VASE IBRION=5 output',
                    default = 'OUTCAR')
group = parser.add_mutually_exclusive_group()
group.add_argument('-f', '--scale',
                    help = 'Scale factor to displace configuration along vib mode',
                    default = None, type=float)
group.add_argument('-n', '--norm',
                   help = 'norm of the displacement vector in Cartesian (not mass weighted) coordinates',
                   default = 0.1, type=float)

parser.add_argument('-m', '--mode',
                    help = 'Mode number (from 0) for which to generate new configurations',
                    type = int, default = None)
args = parser.parse_args()

VASP_OUTCAR = args.input
try:
    fh_outcar = open(VASP_OUTCAR, 'r')
    fh_outcar.close()
except:
    raise IOError("Failed open file '{}', exit..".format(VASP_OUTCAR))

# scale factor related
fixed_norm = False
if not args.scale is None:
    print("Warning: I strongly recommend not use the '-f' argument to specify the scale factor,\n"
          " since in that case I will generate structures with different amount of nucleic displacement.\n"
          "\nPress Ctrl-C to cancel the current generation (in 10 seconds ...)"
    )
    time.sleep(10)
    scale_factor = args.scale
else:
    fixed_norm = True
    disp_norm = args.norm
    print("Using fixed norm for displacement vector: {} Ang".format(disp_norm))
    
    


# first check OUTCAR is generated from a IBRION=5 calculation
out = outcar.OUTCAR(VASP_OUTCAR)
ibrion = int(out.getParameter('IBRION'))
if ibrion != 5:
    print('I am now only support IBRION=5 calculation from VASP')
    raise SystemExit
print('Confirmed OUTCAR is generated by a IBRION = 5 calculation')


# get degrees of freedom
dof = out.getDOF()
print('There are in total {} vibrational modes in the calculation.'.format(
    dof)
)

# get equilibrium configuration
IonsPerType = out.getIonsPerType()
IonTypes = out.getIonTypes()
ions = zip(IonTypes, IonsPerType)
NAtoms = out.getNIons()
#print(ions)

X0 = out.getX0()
latt = out.getLattice()

# construct mode-list for which displaced
if args.mode is None:
    modes = [i+1 for i in range(dof)]
else:
    modes = [args.mode]

# make a new directory for generated displaced configurations
if fixed_norm:
    path = 'n{}'.format(disp_norm)
else:
    path = 'f{}'.format(scale_factor)
    
if os.path.exists(path):
    time_str = datetime.datetime.fromtimestamp(
        os.path.getmtime(path)
    ).strftime("%Y%m%d-%H%M%S")
    new_path = "{}.{}".format(path, time_str)
    print('Directory {} already exists, back up to {}'.format(
        path, new_path
    ))
    shutil.move(path, new_path)

os.mkdir(path)

# construct POSCAR header
first_line = "{} " * len(ions) + "\n"
first_line = first_line.format(*[ion[0] for ion in ions])
header = first_line + " 1.00000\n"
for i in range(3):
    line = "{:24.16f}{:24.16f}{:24.16f}\n".format(*latt[i])
    header += line

sixth_line = " {}" * len(ions) + "\n"
sixth_line = sixth_line.format(*[ion[1] for ion in ions])
header += sixth_line
header += 'Cartesian\n'

# record the scale factor for each normal mode in the fixed_norm generation
fname = '{}/scale.dat'.format(path)
scale_fh = open(fname, 'w')

# displacing coordinates
print("\n\nGenerating displaced geometry:\n")
for mode in modes:
    print("mode #{:3d} :  ".format(mode), end='')
    m = out.getNormalMode(mode)
    omega = m.get('Omega')[2] # angular freq in THz
    l = m.get('mode')

    mu = 1.0 / (np.sum(l*l))
    Q_norm = (1.0 / (2.0*mu*AMTOAU*(omega/NU0_THz))) ** 0.5 * AUTOA
    l_norm = np.sum(l*l) ** 0.5
    print(" mu = {:7.3f}, |Q| = {:7.4f}, |L| = {:7.4f} Ang".format(mu, Q_norm, l_norm))

    if fixed_norm:
        this_factor = disp_norm / l_norm
        scale_fh.write('{:3d}  {:8.4f}\n'.format(mode, disp_norm / Q_norm))
    else:
        this_factor = (Q_norm * scale_factor) / l_norm
    dX = l * this_factor
    #print(this_factor)
    #print(dX)
    #if (mode == 3): break
    dx_max = np.max(np.abs(dX))
    if dx_max < 0.01:
        print(" Warning: too small atomic displacement: max(|dx|) =  {}".format(dx_max))

    # create POSCAR files for positive and negative displaced coord
    #  and write headers to them
    poscar_p = '{}/POSCAR.+m{:03d}'.format(path, mode)
    poscar_p_fh = open(poscar_p, 'w')
    poscar_p_fh.writelines(header)
    poscar_m = '{}/POSCAR.-m{:03d}'.format(path, mode)
    poscar_m_fh = open(poscar_m, 'w')
    poscar_m_fh.writelines(header)

    # write displaced coord to POSCARs
    fmt = "{:24.16f}"*3 + "\n"
    newX = X0 + dX
    print("writing to {} and ".format(poscar_p), end='')
    for i in range(NAtoms):
        poscar_p_fh.write(fmt.format(*newX[i]))
    poscar_p_fh.close()

    newX = X0 - dX
    for i in range(NAtoms):
        poscar_m_fh.write(fmt.format(*newX[i]))
    poscar_m_fh.close()
    print("{}...DONE!\n".format(poscar_m))






